module {
    func.func @apply_rotary_embedding_bf16(
        %x1: tensor<?x?xbf16>,
        %x2: tensor<?x?xbf16>,
        %cos: tensor<?x?xbf16>,
        %sin: tensor<?x?xbf16>,
        %out1: tensor<?x?xbf16>,
        %out2: tensor<?x?xbf16>
    ) -> (tensor<?x?xbf16>, tensor<?x?xbf16>) {

        // Perform the rotary embedding operation
        %cos_x1 = "stablehlo.multiply"(%x1, %cos) : (tensor<?x?xbf16>, tensor<?x?xbf16>) -> tensor<?x?xbf16>
        %sin_x1 = "stablehlo.multiply"(%x1, %sin) : (tensor<?x?xbf16>, tensor<?x?xbf16>) -> tensor<?x?xbf16>
        %out_x1 = "stablehlo.subtract"(%cos_x1, %sin_x1) : (tensor<?x?xbf16>, tensor<?x?xbf16>) -> tensor<?x?xbf16>

        %cos_x2 = "stablehlo.multiply"(%x2, %cos) : (tensor<?x?xbf16>, tensor<?x?xbf16>) -> tensor<?x?xbf16>
        %sin_x2 = "stablehlo.multiply"(%x2, %sin) : (tensor<?x?xbf16>, tensor<?x?xbf16>) -> tensor<?x?xbf16>
        %out_x2 = "stablehlo.add"(%cos_x2, %sin_x2) : (tensor<?x?xbf16>, tensor<?x?xbf16>) -> tensor<?x?xbf16>

        return %out_x1, %out_x2 : tensor<?x?xbf16>, tensor<?x?xbf16>
    }
}